/**
 * This ruleset enforces a hybrid security model for an accounting ERP system.
 * It combines global administrator roles, a user-ownership model for personal data,
 * and a collaborative access model for company-specific data.
 *
 * Core Philosophy:
 * The default posture is deny-all. Access is granted explicitly based on a user's
 * identity and their relationship to the data they are trying to access. Global
 * administrators have broad read access for oversight and specific write access
 * for managing core entities like companies and user roles.
 *
 * Data Structure:
 * - /users/{userId}: Private user profile data, accessible only by the owner and admins.
 * - /roles/{roleId}: Defines permissions for different user roles.
 * - /companies/{companyId}: Top-level documents for each client company. These
 *   contain a denormalized `members` map to control access.
 * - /companies/{companyId}/{subcollection}: Nested data like documents, tax obligations,
 *   and corporate processes inherit their access rights from the parent company's
 *   `members` map.
 *
 * Key Security Decisions:
 * - Admin Rights: Admin privileges are determined by the 'roleId' in the user's
 *   profile document (`/users/{userId}`). This check requires a `get()` call but is
 *   central to the RBAC system. The 'owner' role grants full access.
 * - Company Access: All access to a company's data and its subcollections is
 *   controlled by a `members` map denormalized directly onto the company document.
 *   This avoids slow and costly `get()` calls across different collections in rules.
 * - User Data Privacy: Users can only access their own document within the `/users`
 *   collection. Listing all users is prohibited for non-admins.
 * - Creator-Based Write Rules: Within a company's subcollections, any member can
 *   create new documents, but only the original creator (or an admin) can modify or delete them.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =========================================================================
    // Helper Functions
    // =========================================================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the given userId.
     * Used for document ownership checks.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Retrieves the user's profile document.
     */
    function getUserProfile() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }
    
    /**
     * Retrieves the role document associated with the current user.
     */
    function getUserRole() {
        let userProfile = getUserProfile();
        if (userProfile.data.roleId != null) {
            return get(/databases/$(database)/documents/roles/$(userProfile.data.roleId));
        }
        return null;
    }

    /**
     * Checks if the user has the 'owner' role.
     */
    function isOwnerRole() {
      let userProfile = getUserProfile();
      return userProfile.data.roleId == 'owner';
    }

    /**
     * Checks if the user has a specific granular permission.
     * Example: hasPermission('companies', 'create')
     */
    function hasPermission(resource, operation) {
        let userRole = getUserRole();
        return userRole != null && userRole.data.permissions[resource][operation] == true;
    }

    /**
     * Checks if a user is a member of a specific company by verifying their UID
     * exists as a key in the company's 'members' map.
     */
    function isCompanyMember(companyId) {
      return get(/databases/$(database)/documents/companies/$(companyId)).data.members[request.auth.uid] != null;
    }

    /**
     * Combines owner role and company member checks for granting read access.
     */
    function canReadCompanyData(companyId) {
      return isOwnerRole() || isCompanyMember(companyId);
    }
    
    /**
     * On update/delete, checks if the document exists and if the requesting user
     * is either the original creator (responsibleUserId) or an admin.
     */
    function isExistingResponsibleUserOrAdmin(responsibleUserId) {
      return resource != null && (isOwnerRole() || isOwner(responsibleUserId));
    }

    // =========================================================================
    // Data Validation Helper Functions (Prototyping Mode)
    // =========================================================================
    function isConsistentDocId(docId) {
      return request.resource.data.id == docId;
    }

    function isDocIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    function hasConsistentCompanyId(companyId) {
      return request.resource.data.companyId == companyId;
    }

    function isCompanyIdImmutable() {
      return request.resource.data.companyId == resource.data.companyId;
    }

    function isRequestingUserResponsible() {
      return request.resource.data.responsibleUserId == request.auth.uid;
    }

    function isResponsibleUserImmutableOrAdmin() {
      return isOwnerRole() || request.resource.data.responsavelId == resource.data.responsavelId;
    }

    // =========================================================================
    // Rule Definitions
    // =========================================================================

    /**
     * @description User profile data. A user can manage their own profile. Owners can read any profile.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isOwnerRole();
      allow list: if isOwnerRole();
      allow create: if isOwner(userId); // Allow user to create their own profile doc
      allow update: if isOwner(userId);
      allow delete: if isOwnerRole();
    }
    
    /**
     * @description Roles and permissions definitions. Only owners can manage roles.
     */
    match /roles/{roleId} {
        allow read, write: if isOwnerRole();
    }

    /**
     * @description Company records. Access is controlled by a 'members' map or owner role.
     */
    match /companies/{companyId} {
      allow get: if canReadCompanyData(companyId);
      allow list: if isSignedIn();
      allow create: if isSignedIn(); // Simplified for now
      allow update: if isOwnerRole() || isCompanyMember(companyId);
      allow delete: if isOwnerRole();
    }
    
    /**
     * @description Partner records. Any authenticated user can manage for now.
     */
    match /partners/{partnerId} {
        allow read, write: if isSignedIn();
    }

    /**
     * @description Tax obligations for a company. Inherits access from the parent company.
     */
    match /companies/{companyId}/taxObligations/{taxObligationId} {
      allow get: if canReadCompanyData(companyId);
      allow list: if canReadCompanyData(companyId);
      allow create: if canReadCompanyData(companyId);
      allow update: if canReadCompanyData(companyId);
      allow delete: if canReadCompanyData(companyId);
    }

    /**
     * @description Documents for a company. Inherits access from the parent company.
     */
    match /companies/{companyId}/documents/{documentId} {
      allow get: if canReadCompanyData(companyId);
      allow list: if canReadCompanyData(companyId);
      allow create: if canReadCompanyData(companyId) && isRequestingUserResponsible();
      allow update: if isExistingResponsibleUserOrAdmin(resource.data.responsibleUserId) && isCompanyIdImmutable();
      allow delete: if isExistingResponsibleUserOrAdmin(resource.data.responsibleUserId);
    }

    /**
     * @description Corporate processes for a company. Inherits access from the parent company.
     */
    match /companies/{companyId}/corporateProcesses/{corporateProcessId} {
      allow get: if canReadCompanyData(companyId);
      allow list: if canReadCompanyData(companyId);
      allow create: if canReadCompanyData(companyId) && isRequestingUserResponsible();
      allow update: if isExistingResponsibleUserOrAdmin(resource.data.responsibleUserId) && isCompanyIdImmutable();
      allow delete: if isExistingResponsibleUserOrAdmin(resource.data.responsibleUserId);
    }
  }
}
